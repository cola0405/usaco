'''
C++
图论 + 状态dp

题目大意：可以增加或者删除边，使得图满足如下情况，除开有边相连的任意两点 a、b外，其他的所有点都至少与 a或者 b相连
题目思路：
需要把图转化为补图研究（补图就是连接/不连接倒转）
题目要求转化到补图中，则变为若干个完全子图
解释：
对于满足上面条件的图
ab相连， ac不相连，那 bc一定相连
将上述关系如果转化到补图则变为：（ac相连，则 bc不相连）
图会变成： a——c b （b是一个单独的点）
如果有更多的 d、e、f点同 c的情况，则图会变为：a——c、d、e、f b （a与 c、d、e、f相连，然后 b是单独的一个点，这是两个完全子图）
把图的情况普遍化，b在原图中也有一些不相连的点，那情况就会变为 a连了一堆点称为点集 S1，b连了点集 S2，恰好是两个完全子图
a——c、d、e、f
b——g、h、i

这点明白之后，我们接下来看如何在补图中求解
在这里 N只给到 16很难不让人考虑状态dp
说到状态 dp就考虑到枚举了，那怎么模拟添加、删除边的操作呢？
这里先构建一个数组，a[S] 表示将某 S子图转化为完全子图所需要的操作次数
求解过程就是用双重循环来匹配子图 S中的点和所有点（注意，不是只在子图中匹配）
a是子图 S中的点，b是总点集中的点
1.如果 b也处于子图中，当 ab不相连时，操作数+1
2.如果 b在子图之外，当 ab相连时，操作数+1（要把这条边删掉，不然会影响当前完全子图）

接下来我们再讨论将图构造为若干完全子图所需要的最少操作次数
设置 dp[S] 表示 S状态下，构造若干完全子图所需要的最少操作次数
dp[S] = min(dp[S], dp[S^s] + a[s])  s表示 S的某个子图
可以认为除了子图 s 其他部分都已构成完全子图，然后加上当前这个子图 s所需要的操作次数，从而得到把整个图转化为若干子图的最少操作次数
'''


n,m = map(int,input().split())
g = [[1]*n for _ in range(n)]
for i in range(m):
    a,b = map(int,input().split())
    a -= 1
    b -= 1
    g[a][b] = g[b][a] = 0

a = [0] * (1<<n)        # a[S] 表示使得子集 S成为完全图的最小边数
for S in range(1, 1<<n):
    for i in range(n):
        if S & (1<<i):
            for j in range(n):
                if i == j: continue
                if S & (1<<j) and g[i][j] == 0:
                    a[S] += 1
                elif not S & (1<<j) and g[i][j]:                   # 如果 j不在 S中，且(i,j)之间存在边，则需要移除边，操作数也+1
                    a[S] += 1

dp = [0] * (1<<n)
dp[0] = 0
for S in range(1, 1<<n):
    dp[S] = a[S]
    # 枚举子集 S 的非空子集
    s = S
    while s:
        dp[S] = min(dp[S], dp[S^s] + a[s])
        s = (s-1)&S
print(dp[(1<<n) - 1] // 2)

