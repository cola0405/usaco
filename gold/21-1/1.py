'''
C++
状态压缩 dp

题目大意：
题目没有明确字母表顺序，然后给一个字符串 s，问最少重复唱几次可以完成 s

（题目的数据范围其实有提示，Farmer Nhoj never heard any of the letters that appear in Mildred's name.
说明最多 20个字母，2^20 正好是 10^7 的数量级 —— 可以状态压缩）

暴力枚举排列情况肯定不行，所以这道题另辟蹊径 —— 直接利用状态压缩 dp来解题
思路如下：
集合状态 S是一串二进制位，0表示不考虑某种字母，1表示考虑
dp[S] 表示某种状态 S下唱的最小次数，dp[1<<m - 1]是最终答案 即 dp[11...11] 表示当前 s涉及到的所有字母都在时，唱的最小次数（m为 s中的字母种类数）
dp[11...11] 可以由很多种状态转移而来，如：dp[11...10] dp[11...101] 等（某位为 0表示不包含那一个字母时唱的最小次数）
状态转移方程：
dp[11...11] = 某个字母 x还没纳入统计的状态 dp[11..10] + 字母 x引起的重复唱的次数


1.这种 dp思路是如何等同于枚举所有排列的呢？
状态 S会枚举所有的字母集合，然后对于字母 x，我们认为状态 S字母集合中的字母都在字母 x之前
结合上面的状态转移方程，其实就等效于我们枚举了所有的排列情况 —— 有哪些字母是在 x之前
字母 x引起的重复唱的次数，也就是 “字母x + 其他字母 ” 在 s中出现的总次数 —— 就是cnt在统计的东西

2.如何求得某个字母 x引起的重复唱的次数？
说到底，是否重复唱，其实就取决于相邻的两个元素
如果这两个元素的顺序在字母表中没问题就不用 +1
那我们其实把 s扫一遍，然后统计对应数量就行了
（状态转移时如何利用 cnt我会在第 3点阐述）

3.如何证明上述状态转移方程的正确性呢？
每次状态转移我们认为 S中的有效字母都在字母 x前面 —— 这个处理是为了方便统计，你也可以认为是字母 x在所有字母的前面，然后去+cnt[0,1,2,...][x]
问题的关键其实在于统计出字母 x在当前状态下会引起的重复唱 —— 为了之后的状态转移（这里其实就是dp的灵魂，可意会不可言传了。。。）
所以我们把所有（字母 x 、其他字母）的情况都统计起来 —— 即 tot += cnt[al[i]][al[j]]
al[i] 定下，枚举所有 al[j]
'''
from collections import defaultdict
s = input()
al = list(set(s))     # 看列表中存在哪些字母
n = len(s)
m = len(al)           # s中涉及的字母种类数
cnt = defaultdict(lambda: defaultdict(int))     # 统计相邻字母的出现次数
for i in range(n-1):
    cnt[s[i]][s[i+1]] += 1

dp = [float('inf')] * (1<<m)
dp[0] = 1       # 默认一开始需要唱一次
for S in range(1, 1<<m):        # 枚举所有状态 S（二进制串）
    for i in range(m):          # 开始枚举可能转移到 dp[S]的状态
        if S & (1<<i):          # 状态 S涉及到的才处理
            tot = dp[S ^ (1<<i)]
            for j in range(m):  # 把每个字母都枚举一遍，看 al[i]总共能造成多少次重复唱
                if S & (1<<j):
                    tot += cnt[al[i]][al[j]]
            dp[S] = min(dp[S], tot)
print(dp[-1])
