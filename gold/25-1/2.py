'''
并查集 + 逆向处理

题目大意：问删除某点后，有多少对点仍然是连通的？
删除分两种操作，0 —— 单纯删除某个点， 1 —— 删除该点后，会给该节点的相邻节点之间都加上一条边

思路：涉及到删除操作，正向维护并查集困难考虑逆向加点
对于 0类型的处理比较朴素，遍历其相邻节点的块（我们只考虑已经加入进来的那些点，还没加入进来的点会在之后处理到）
此时数量 + 两块之间节点数的乘积
对于 1类型的处理则比较麻烦，看似核心的一个关键点在于我们要维护 "新添加边"
但其实这些边其实不用做实际的添加，其本质其实是 —— 连通性的维护
我们需要把 1类型节点相邻的节点们之间的连通性提前维护好
处理的思路其实就是：逆向处理某节点 a时，如果它某个相邻节点 x是类型 1，则把它提前合并到对应的块中去，而不需要等处理到点 x了再合并
这其实就是我们前面说的把连通性提前维护好（这些连通的对数本就该这个时候纳入统计的，点 x移除之后这些连接关系确实是存在的）

这里注意，虽然边只是在 x的相邻节点之间加，但是其连通关系的影响范围更广
如果 a、b 两点是类型 1节点 x的相邻节点，那么在删除 x的时候，看似只是 a-b连上了一条边，但其同时还意味着 a的块与 b的块也连通了
其增加的连通对数 = a块节点数 * b块节点数

对于 1类型的数量统计，确实比较复杂，没办法一次性都算清，得一边合并一边计算
把 a合并进 x时，是加上（a块内节点数 * x块内节点数）
这时你可能会想，x块内可能还有未合并进来的点，这部分的配对数应该怎么处理呢？
假设未合并进来的是点 b，那么注意，上面 a合并进 x后，x的块已经扩大了
那 b合并进 x的时候做的（b块内节点数 * x块内节点数） 其实已经包含了 a块的那些节点，所以不会遗漏，只是统计过程比较复杂

总结一下：对数量有贡献的地方主要分两种，块与块之间的合并以及块内的统计
'''


from collections import defaultdict

def find(x):
    if root[x] != x: root[x] = find(root[x])
    return root[x]

def merge(u, v):       # 更新 root数组、累计连通节点对数、更新块内节点数
    if find(u) == find(v): return         # 已经在同一个块内的就不乘了，避免重复算
    global tot
    tot += cnt[find(v)] * cnt[find(u)]    # 两个块之间合并，则新增的对数是两块节点数乘积
    cnt[find(v)] += cnt[find(u)]          # 只更新合并后的根节点的 cnt即可，旧的根节点之后不会用到的（find()只会找到最新的根节点）
    root[find(u)] = find(v)               # 计数完了再合并

g = defaultdict(list)
cnt = defaultdict(int)      # 统计并查集各块的节点数
n,m = map(int,input().split())
s = input()
root = list(range(n))
for i in range(m):
    a,b = map(int, input().split())
    a -= 1
    b -= 1
    g[a].append(b)
    g[b].append(a)
    if s[a] == s[b] == '1':       # 这里不太好理解，这是为了避免重复计算，互为 1的两个节点会在后面 merge两次，会造成重复计算
        root[find(a)] = find(b)   # 所以提前连通它们，使得到时它们会按照 + 1 + 2 + 3 来累计两个块之间的所有连通对数

ans = [0]*n
tot = 0
for i in range(n)[::-1]:        # 逆向加点
    for j in g[i]:
        if j > i or s[j] == '1':        # 只处理已经加入的点，或者点 j是操作类型 1，也是需要马上新增连通的对数 —— 可以在 merge中完成
            merge(i, j)

    tot += cnt[find(i)]  # 块内的统计，当前新增的点 x可以与块内的所有点都连上
    cnt[find(i)] += 1    # 之后才把当前节点纳入当前块的节点数量
    ans[i] = tot

for a in ans:
    print(a)
